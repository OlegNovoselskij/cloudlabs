"""
2024
krex5@github.com
Â© CloudLabs Project
"""

import os
import re
from datetime import datetime, timedelta
from http import HTTPStatus
import secrets
import jwt
from typing import Dict, Any
from functools import wraps
from urllib.parse import quote_plus

from dotenv import load_dotenv
from flasgger import Swagger
from flask import Flask, jsonify, request, g
from flask_restx import Api, Resource, fields
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import text
from sqlalchemy_utils import database_exists, create_database
from apispec import APISpec
from apispec_webframeworks.flask import FlaskPlugin
from flask_swagger_ui import get_swaggerui_blueprint
from flask_cors import CORS
from werkzeug.security import generate_password_hash, check_password_hash

from my_project.auth.route import register_routes

SECRET_KEY = "SECRET_KEY"
SQLALCHEMY_DATABASE_URI = "SQLALCHEMY_DATABASE_URI"
MYSQL_ROOT_USER = "MYSQL_ROOT_USER"
MYSQL_ROOT_PASSWORD = "MYSQL_ROOT_PASSWORD"

# Database
db = SQLAlchemy()

todos = {}


def create_app(app_config: Dict[str, Any], additional_config: Dict[str, Any]) -> Flask:
    """
    Creates Flask application
    :param app_config: Flask configuration
    :param additional_config: additional configuration
    :return: Flask application object
    """
    _process_input_config(app_config, additional_config)
    app = Flask(__name__)
    app.config["SECRET_KEY"] = secrets.token_hex(16)
    app.config = {**app.config, **app_config}

    CORS(app)
    _init_db(app)
    register_routes(app)
    _init_swagger(app)

    return app


def init_autodoc_swagger(app: Flask) -> None:
    app.config.setdefault("SWAGGER", {
        "uiversion": 3,
        "title": "CloudLabs Management API",
        "openapi": "3.0.3",
    })

    swagger_template = {
        "openapi": "3.0.3",
        "info": {
            "title": "CloudLabs Management API",
            "version": "1.0.0",
            "description": "Autogenerated Swagger docs for CloudLabs system",
            "contact": {"name": "CloudLabs Team", "email": "krex5@github.com"},
            "license": {"name": "MIT"},
        },
        "servers": [
            {"url": "/"}
        ],
        "components": {
            "securitySchemes": {
                "bearerAuth": {
                    "type": "http",
                    "scheme": "bearer",
                    "bearerFormat": "JWT"
                }
            }
        },
        "security": [{"bearerAuth": []}],
    }

    Swagger(app, template=swagger_template)


def _init_swagger(app: Flask) -> None:
    authorizations = {
        'Bearer': {
            'type': 'apiKey',
            'in': 'header',
            'name': 'Authorization',
            'description': 'JWT Token. Format: Bearer <token>'
        }
    }
    
    api = Api(
        app, 
        title='CloudLabs Management System API',
        description='Complete REST API for CloudLabs management system with authentication',
        version='1.0',
        doc='/api/docs/',
        prefix='/api/v1',
        authorizations=authorizations,
        security='Bearer'
    )
    
    # CloudLabs models
    user_model = api.model('User', {
        'user_id': fields.Integer(description='User ID'),
        'username': fields.String(required=True, description='Username'),
        'email': fields.String(required=True, description='Email address'),
        'password': fields.String(required=True, description='Password'),
        'role': fields.String(description='User role')
    })
    
    customer_model = api.model('Customer', {
        'customer_id': fields.Integer(description='Customer ID'),
        'name': fields.String(required=True, description='Customer name'),
        'contact_info': fields.String(description='Contact information'),
        'address': fields.String(description='Customer address')
    })
    
    location_model = api.model('Location', {
        'location_id': fields.Integer(description='Location ID'),
        'name': fields.String(required=True, description='Location name'),
        'address': fields.String(description='Location address'),
        'coordinates': fields.String(description='Location coordinates')
    })
    
    pump_model = api.model('Pump', {
        'pump_id': fields.Integer(description='Pump ID'),
        'name': fields.String(required=True, description='Pump name'),
        'location_id': fields.Integer(description='Location ID'),
        'status': fields.String(description='Pump status'),
        'capacity': fields.Float(description='Pump capacity')
    })
    
    pump_operation_model = api.model('PumpOperation', {
        'operation_id': fields.Integer(description='Operation ID'),
        'pump_id': fields.Integer(description='Pump ID'),
        'start_time': fields.DateTime(description='Operation start time'),
        'end_time': fields.DateTime(description='Operation end time'),
        'status': fields.String(description='Operation status')
    })
    
    sensor_model = api.model('Sensor', {
        'sensor_id': fields.Integer(description='Sensor ID'),
        'name': fields.String(required=True, description='Sensor name'),
        'type': fields.String(description='Sensor type'),
        'location_id': fields.Integer(description='Location ID'),
        'status': fields.String(description='Sensor status')
    })
    
    sensor_reading_model = api.model('SensorReading', {
        'reading_id': fields.Integer(description='Reading ID'),
        'sensor_id': fields.Integer(description='Sensor ID'),
        'value': fields.Float(description='Reading value'),
        'timestamp': fields.DateTime(description='Reading timestamp'),
        'unit': fields.String(description='Measurement unit')
    })
    
    sensor_type_model = api.model('SensorType', {
        'type_id': fields.Integer(description='Sensor Type ID'),
        'name': fields.String(required=True, description='Type name'),
        'description': fields.String(description='Type description'),
        'unit': fields.String(description='Measurement unit')
    })
    
    coordinates_model = api.model('Coordinates', {
        'coordinate_id': fields.Integer(description='Coordinate ID'),
        'latitude': fields.Float(required=True, description='Latitude'),
        'longitude': fields.Float(required=True, description='Longitude'),
        'location_id': fields.Integer(description='Location ID')
    })
    
    sensors_coordinates_model = api.model('SensorsCoordinates', {
        'id': fields.Integer(description='ID'),
        'sensor_id': fields.Integer(description='Sensor ID'),
        'coordinate_id': fields.Integer(description='Coordinate ID')
    })
    
    sopla_model = api.model('Sopla', {
        'sopla_id': fields.Integer(description='Sopla ID'),
        'name': fields.String(required=True, description='Sopla name'),
        'description': fields.String(description='Sopla description'),
        'status': fields.String(description='Sopla status')
    })
    
    # Authentication models
    login_model = api.model('Login', {
        'username': fields.String(required=True, description='Username'),
        'password': fields.String(required=True, description='Password')
    })
    
    register_model = api.model('Register', {
        'username': fields.String(required=True, description='Username'),
        'password': fields.String(required=True, description='Password'),
        'email': fields.String(required=True, description='Email')
    })
    
    # Response models
    message_response_model = api.model('MessageResponse', {
        'message': fields.String(description='Response message')
    })
    
    token_response_model = api.model('TokenResponse', {
        'token': fields.String(description='JWT Access Token'),
        'user': fields.Nested(api.model('UserInfo', {
            'user_id': fields.Integer(description='User ID'),
            'username': fields.String(description='Username'),
            'email': fields.String(description='Email')
        })),
        'message': fields.String(description='Success message')
    })
    
    health_model = api.model('HealthStatus', {
        'status': fields.String(description='System status'),
        'message': fields.String(description='Status message'),
        'version': fields.String(description='API version'),
        'database': fields.String(description='Database status'),
        'timestamp': fields.String(description='Current timestamp')
    })
    
    def token_required(f):
        @wraps(f)
        def decorated(*args, **kwargs):
            token = request.headers.get('Authorization')
            if not token:
                api.abort(401, 'Token is missing!')
            
            try:
                if token.startswith('Bearer '):
                    token = token[7:]
                data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
                g.current_user = data['username']
            except:
                api.abort(401, 'Invalid token!')
            
            return f(*args, **kwargs)
        return decorated
    
    def get_dao_data(dao_class, method_name='find_all', *args):
        """Helper function to get data from DAO"""
        try:
            dao = dao_class()
            method = getattr(dao, method_name)
            if args:
                result = method(*args)
            else:
                result = method()
            if result is None:
                return []
            if hasattr(result, '__iter__') and not isinstance(result, str):
                return [item.put_into_dto() for item in result]
            else:
                return result.put_into_dto() if hasattr(result, 'put_into_dto') else result
        except Exception as e:
            print(f"Error in get_dao_data: {e}")
            return []
    
    # Mock users for authentication
    users_db = {
        'admin': {
            'user_id': 1,
            'username': 'admin',
            'email': 'admin@cloudlabs.com',
            'password': generate_password_hash('admin123'),
            'role': 'admin'
        },
        'user': {
            'user_id': 2,
            'username': 'user',
            'email': 'user@cloudlabs.com', 
            'password': generate_password_hash('user123'),
            'role': 'user'
        }
    }
    
    # Create namespaces
    ns_auth = api.namespace('auth', description='Authentication and authorization')
    ns_users = api.namespace('users', description='User management')
    ns_customers = api.namespace('customers', description='Customer management')
    ns_locations = api.namespace('locations', description='Location management')
    ns_pumps = api.namespace('pumps', description='Pump management')
    ns_pump_operations = api.namespace('pump-operations', description='Pump operations management')
    ns_sensors = api.namespace('sensors', description='Sensor management')
    ns_sensor_readings = api.namespace('sensor-readings', description='Sensor readings management')
    ns_sensor_types = api.namespace('sensor-types', description='Sensor types management')
    ns_coordinates = api.namespace('coordinates', description='Coordinates management')
    ns_sensors_coordinates = api.namespace('sensors-coordinates', description='Sensors coordinates management')
    ns_sopla = api.namespace('sopla', description='Sopla management')
    ns_health = api.namespace('health', description='System monitoring')
    
    # Authentication endpoints
    @ns_auth.route('/register')
    class Register(Resource):
        @api.expect(register_model)
        @api.marshal_with(message_response_model)
        def post(self):
            """Register new user"""
            data = request.get_json()
            username = data.get('username')
            
            if not username or not data.get('password') or not data.get('email'):
                api.abort(400, 'Username, password and email are required')
            
            if username in users_db:
                api.abort(400, f'User {username} already exists')
            
            users_db[username] = {
                'user_id': len(users_db) + 1,
                'username': username,
                'email': data.get('email'),
                'password': generate_password_hash(data.get('password')),
                'role': 'user'
            }
            
            return {'message': f'User {username} registered successfully!'}, 201
    
    @ns_auth.route('/login')
    class Login(Resource):
        @api.expect(login_model)
        @api.marshal_with(token_response_model)
        def post(self):
            """Login and get JWT token"""
            data = request.get_json()
            username = data.get('username')
            password = data.get('password')
            
            user = users_db.get(username)
            if not user or not check_password_hash(user['password'], password):
                api.abort(401, 'Invalid credentials')
            
            token = jwt.encode({
                'username': username,
                'exp': datetime.utcnow() + timedelta(hours=24)
            }, app.config['SECRET_KEY'], algorithm='HS256')
            
            return {
                'token': token,
                'user': {
                    'user_id': user['user_id'],
                    'username': user['username'],
                    'email': user['email']
                },
                'message': 'Login successful!'
            }
    
    # Users endpoints
    @ns_users.route('/')
    class UsersList(Resource):
        @api.marshal_list_with(user_model)
        def get(self):
            """Get all users"""
            try:
                from my_project.auth.dao.orders.UserDAO import UserDAO
                return get_dao_data(UserDAO)
            except Exception as e:
                print(f"Error getting users: {e}")
                return []
        
        @api.doc(security='Bearer')
        @token_required
        @api.expect(user_model)
        @api.marshal_with(user_model)
        def post(self):
            """Create new user"""
            try:
                from my_project.auth.dao.orders.UserDAO import UserDAO
                from my_project.auth.domain.orders.Users import User
                data = request.get_json()
                user = User.create_from_dto(data)
                dao = UserDAO()
                dao.create(user)
                return user.put_into_dto(), 201
            except Exception as e:
                print(f"Error creating user: {e}")
                api.abort(500, 'Internal server error')
    
    @ns_users.route('/<int:user_id>')
    class User(Resource):
        @api.marshal_with(user_model)
        def get(self, user_id):
            """Get user by ID"""
            try:
                from my_project.auth.dao.orders.UserDAO import UserDAO
                dao = UserDAO()
                user = dao.find_by_id(user_id)
                if not user:
                    api.abort(404, 'User not found')
                return user.put_into_dto()
            except Exception as e:
                print(f"Error getting user {user_id}: {e}")
                api.abort(500, 'Internal server error')
        
        @api.doc(security='Bearer')
        @token_required
        @api.expect(user_model)
        @api.marshal_with(message_response_model)
        def put(self, user_id):
            """Update user by ID"""
            try:
                from my_project.auth.dao.orders.UserDAO import UserDAO
                from my_project.auth.domain.orders.Users import User
                data = request.get_json()
                user = User.create_from_dto(data)
                dao = UserDAO()
                dao.update(user_id, user)
                return {'message': 'User updated successfully'}
            except Exception as e:
                print(f"Error updating user {user_id}: {e}")
                api.abort(500, 'Internal server error')
        
        @api.doc(security='Bearer')
        @token_required
        @api.marshal_with(message_response_model)
        def delete(self, user_id):
            """Delete user by ID"""
            try:
                from my_project.auth.dao.orders.UserDAO import UserDAO
                dao = UserDAO()
                dao.delete(user_id)
                return {'message': 'User deleted successfully'}
            except Exception as e:
                print(f"Error deleting user {user_id}: {e}")
                api.abort(500, 'Internal server error')
    
    # Customers endpoints
    @ns_customers.route('/')
    class CustomersList(Resource):
        @api.marshal_list_with(customer_model)
        def get(self):
            """Get all customers"""
            try:
                from my_project.auth.dao.orders.CustomerDAO import CustomerDAO
                return get_dao_data(CustomerDAO)
            except Exception as e:
                print(f"Error getting customers: {e}")
                return []
        
        @api.doc(security='Bearer')
        @token_required
        @api.expect(customer_model)
        @api.marshal_with(customer_model)
        def post(self):
            """Create new customer"""
            try:
                from my_project.auth.dao.orders.CustomerDAO import CustomerDAO
                from my_project.auth.domain.orders.Customers import Customer
                data = request.get_json()
                customer = Customer.create_from_dto(data)
                dao = CustomerDAO()
                dao.create(customer)
                return customer.put_into_dto(), 201
            except Exception as e:
                print(f"Error creating customer: {e}")
                api.abort(500, 'Internal server error')
    
    @ns_customers.route('/<int:customer_id>')
    class Customer(Resource):
        @api.marshal_with(customer_model)
        def get(self, customer_id):
            """Get customer by ID"""
            try:
                from my_project.auth.dao.orders.CustomerDAO import CustomerDAO
                dao = CustomerDAO()
                customer = dao.find_by_id(customer_id)
                if not customer:
                    api.abort(404, 'Customer not found')
                return customer.put_into_dto()
            except Exception as e:
                print(f"Error getting customer {customer_id}: {e}")
                api.abort(500, 'Internal server error')
    
    # Locations endpoints
    @ns_locations.route('/')
    class LocationsList(Resource):
        @api.marshal_list_with(location_model)
        def get(self):
            """Get all locations"""
            try:
                from my_project.auth.dao.orders.LocationDAO import LocationDAO
                return get_dao_data(LocationDAO)
            except Exception as e:
                print(f"Error getting locations: {e}")
                return []
        
        @api.doc(security='Bearer')
        @token_required
        @api.expect(location_model)
        @api.marshal_with(location_model)
        def post(self):
            """Create new location"""
            try:
                from my_project.auth.dao.orders.LocationDAO import LocationDAO
                from my_project.auth.domain.orders.Locations import Location
                data = request.get_json()
                location = Location.create_from_dto(data)
                dao = LocationDAO()
                dao.create(location)
                return location.put_into_dto(), 201
            except Exception as e:
                print(f"Error creating location: {e}")
                api.abort(500, 'Internal server error')
    
    # Pumps endpoints
    @ns_pumps.route('/')
    class PumpsList(Resource):
        @api.marshal_list_with(pump_model)
        def get(self):
            """Get all pumps"""
            try:
                from my_project.auth.dao.orders.PumpDAO import PumpDAO
                return get_dao_data(PumpDAO)
            except Exception as e:
                print(f"Error getting pumps: {e}")
                return []
        
        @api.doc(security='Bearer')
        @token_required
        @api.expect(pump_model)
        @api.marshal_with(pump_model)
        def post(self):
            """Create new pump"""
            try:
                from my_project.auth.dao.orders.PumpDAO import PumpDAO
                from my_project.auth.domain.orders.Pumps import Pump
                data = request.get_json()
                pump = Pump.create_from_dto(data)
                dao = PumpDAO()
                dao.create(pump)
                return pump.put_into_dto(), 201
            except Exception as e:
                print(f"Error creating pump: {e}")
                api.abort(500, 'Internal server error')
    
    # Pump Operations endpoints
    @ns_pump_operations.route('/')
    class PumpOperationsList(Resource):
        @api.marshal_list_with(pump_operation_model)
        def get(self):
            """Get all pump operations"""
            try:
                from my_project.auth.dao.orders.PumpOperationDAO import PumpOperationDAO
                return get_dao_data(PumpOperationDAO)
            except Exception as e:
                print(f"Error getting pump operations: {e}")
                return []
        
        @api.doc(security='Bearer')
        @token_required
        @api.expect(pump_operation_model)
        @api.marshal_with(pump_operation_model)
        def post(self):
            """Create new pump operation"""
            try:
                from my_project.auth.dao.orders.PumpOperationDAO import PumpOperationDAO
                from my_project.auth.domain.orders.PumpOperations import PumpOperation
                data = request.get_json()
                operation = PumpOperation.create_from_dto(data)
                dao = PumpOperationDAO()
                dao.create(operation)
                return operation.put_into_dto(), 201
            except Exception as e:
                print(f"Error creating pump operation: {e}")
                api.abort(500, 'Internal server error')
    
    # Sensors endpoints
    @ns_sensors.route('/')
    class SensorsList(Resource):
        @api.marshal_list_with(sensor_model)
        def get(self):
            """Get all sensors"""
            try:
                from my_project.auth.dao.orders.SensorDAO import SensorDAO
                return get_dao_data(SensorDAO)
            except Exception as e:
                print(f"Error getting sensors: {e}")
                return []
        
        @api.doc(security='Bearer')
        @token_required
        @api.expect(sensor_model)
        @api.marshal_with(sensor_model)
        def post(self):
            """Create new sensor"""
            try:
                from my_project.auth.dao.orders.SensorDAO import SensorDAO
                from my_project.auth.domain.orders.Sensors import Sensor
                data = request.get_json()
                sensor = Sensor.create_from_dto(data)
                dao = SensorDAO()
                dao.create(sensor)
                return sensor.put_into_dto(), 201
            except Exception as e:
                print(f"Error creating sensor: {e}")
                api.abort(500, 'Internal server error')
    
    # Sensor Readings endpoints
    @ns_sensor_readings.route('/')
    class SensorReadingsList(Resource):
        @api.marshal_list_with(sensor_reading_model)
        def get(self):
            """Get all sensor readings"""
            try:
                from my_project.auth.dao.orders.SensorReadingDAO import SensorReadingDAO
                return get_dao_data(SensorReadingDAO)
            except Exception as e:
                print(f"Error getting sensor readings: {e}")
                return []
        
        @api.doc(security='Bearer')
        @token_required
        @api.expect(sensor_reading_model)
        @api.marshal_with(sensor_reading_model)
        def post(self):
            """Create new sensor reading"""
            try:
                from my_project.auth.dao.orders.SensorReadingDAO import SensorReadingDAO
                from my_project.auth.domain.orders.SensorReadings import SensorReading
                data = request.get_json()
                reading = SensorReading.create_from_dto(data)
                dao = SensorReadingDAO()
                dao.create(reading)
                return reading.put_into_dto(), 201
            except Exception as e:
                print(f"Error creating sensor reading: {e}")
                api.abort(500, 'Internal server error')
    
    # Sensor Types endpoints
    @ns_sensor_types.route('/')
    class SensorTypesList(Resource):
        @api.marshal_list_with(sensor_type_model)
        def get(self):
            """Get all sensor types"""
            try:
                from my_project.auth.dao.orders.SensorTypeDAO import SensorTypeDAO
                return get_dao_data(SensorTypeDAO)
            except Exception as e:
                print(f"Error getting sensor types: {e}")
                return []
        
        @api.doc(security='Bearer')
        @token_required
        @api.expect(sensor_type_model)
        @api.marshal_with(sensor_type_model)
        def post(self):
            """Create new sensor type"""
            try:
                from my_project.auth.dao.orders.SensorTypeDAO import SensorTypeDAO
                from my_project.auth.domain.orders.SensorsType import SensorsType
                data = request.get_json()
                sensor_type = SensorsType.create_from_dto(data)
                dao = SensorTypeDAO()
                dao.create(sensor_type)
                return sensor_type.put_into_dto(), 201
            except Exception as e:
                print(f"Error creating sensor type: {e}")
                api.abort(500, 'Internal server error')
    
    # Coordinates endpoints
    @ns_coordinates.route('/')
    class CoordinatesList(Resource):
        @api.marshal_list_with(coordinates_model)
        def get(self):
            """Get all coordinates"""
            try:
                from my_project.auth.dao.orders.CoordinateDAO import CoordinateDAO
                return get_dao_data(CoordinateDAO)
            except Exception as e:
                print(f"Error getting coordinates: {e}")
                return []
        
        @api.doc(security='Bearer')
        @token_required
        @api.expect(coordinates_model)
        @api.marshal_with(coordinates_model)
        def post(self):
            """Create new coordinates"""
            try:
                from my_project.auth.dao.orders.CoordinateDAO import CoordinateDAO
                from my_project.auth.domain.orders.Coordinates import Coordinates
                data = request.get_json()
                coordinates = Coordinates.create_from_dto(data)
                dao = CoordinateDAO()
                dao.create(coordinates)
                return coordinates.put_into_dto(), 201
            except Exception as e:
                print(f"Error creating coordinates: {e}")
                api.abort(500, 'Internal server error')
    
    # Sensors Coordinates endpoints
    @ns_sensors_coordinates.route('/')
    class SensorsCoordinatesList(Resource):
        @api.marshal_list_with(sensors_coordinates_model)
        def get(self):
            """Get all sensors coordinates"""
            try:
                from my_project.auth.dao.orders.SensorsCoordinatesDAO import SensorsCoordinatesDAO
                return get_dao_data(SensorsCoordinatesDAO)
            except Exception as e:
                print(f"Error getting sensors coordinates: {e}")
                return []
        
        @api.doc(security='Bearer')
        @token_required
        @api.expect(sensors_coordinates_model)
        @api.marshal_with(sensors_coordinates_model)
        def post(self):
            """Create new sensors coordinates"""
            try:
                from my_project.auth.dao.orders.SensorsCoordinatesDAO import SensorsCoordinatesDAO
                from my_project.auth.domain.orders.SensorsCoordinates import SensorsCoordinates
                data = request.get_json()
                sensors_coordinates = SensorsCoordinates.create_from_dto(data)
                dao = SensorsCoordinatesDAO()
                dao.create(sensors_coordinates)
                return sensors_coordinates.put_into_dto(), 201
            except Exception as e:
                print(f"Error creating sensors coordinates: {e}")
                api.abort(500, 'Internal server error')
    
    # Sopla endpoints
    @ns_sopla.route('/')
    class SoplaList(Resource):
        @api.marshal_list_with(sopla_model)
        def get(self):
            """Get all sopla records"""
            try:
                from my_project.auth.dao.orders.SoplaDAO import SoplaDAO
                return get_dao_data(SoplaDAO)
            except Exception as e:
                print(f"Error getting sopla records: {e}")
                return []
        
        @api.doc(security='Bearer')
        @token_required
        @api.expect(sopla_model)
        @api.marshal_with(sopla_model)
        def post(self):
            """Create new sopla record"""
            try:
                from my_project.auth.dao.orders.SoplaDAO import SoplaDAO
                from my_project.auth.domain.orders.Sopla import Sopla
                data = request.get_json()
                sopla = Sopla.create_from_dto(data)
                dao = SoplaDAO()
                dao.create(sopla)
                return sopla.put_into_dto(), 201
            except Exception as e:
                print(f"Error creating sopla record: {e}")
                api.abort(500, 'Internal server error')
    
    # Health check endpoint
    @ns_health.route('/status')
    class HealthCheck(Resource):
        @api.marshal_with(health_model)
        def get(self):
            """System health check"""
            return {
                'status': 'healthy',
                'message': 'CloudLabs Management System API is running!',
                'version': '1.0',
                'database': 'connected',
                'timestamp': datetime.utcnow().isoformat()
            }
    
    # Root endpoint
    @app.route("/")
    def hello_world():
        return jsonify({
            'message': 'Welcome to CloudLabs Management System API!',
            'docs_url': '/api/docs/',
            'api_version': '1.0',
            'features': [
                'JWT Authentication',
                'User Management',
                'Customer Management',
                'Location Management',
                'Pump Management',
                'Sensor Management',
                'Real-time Data Collection',
                'System Monitoring'
            ],
            'endpoints': {
                'authentication': {
                    'login': '/api/v1/auth/login',
                    'register': '/api/v1/auth/register'
                },
                'users': {
                    'list': '/api/v1/users/',
                    'by_id': '/api/v1/users/{id}'
                },
                'customers': {
                    'list': '/api/v1/customers/',
                    'by_id': '/api/v1/customers/{id}'
                },
                'locations': {
                    'list': '/api/v1/locations/',
                    'by_id': '/api/v1/locations/{id}'
                },
                'pumps': {
                    'list': '/api/v1/pumps/',
                    'by_id': '/api/v1/pumps/{id}'
                },
                'pump_operations': {
                    'list': '/api/v1/pump-operations/',
                    'by_id': '/api/v1/pump-operations/{id}'
                },
                'sensors': {
                    'list': '/api/v1/sensors/',
                    'by_id': '/api/v1/sensors/{id}'
                },
                'sensor_readings': {
                    'list': '/api/v1/sensor-readings/',
                    'by_id': '/api/v1/sensor-readings/{id}'
                },
                'sensor_types': {
                    'list': '/api/v1/sensor-types/',
                    'by_id': '/api/v1/sensor-types/{id}'
                },
                'coordinates': {
                    'list': '/api/v1/coordinates/',
                    'by_id': '/api/v1/coordinates/{id}'
                },
                'sensors_coordinates': {
                    'list': '/api/v1/sensors-coordinates/',
                    'by_id': '/api/v1/sensors-coordinates/{id}'
                },
                'sopla': {
                    'list': '/api/v1/sopla/',
                    'by_id': '/api/v1/sopla/{id}'
                },
                'system': {
                    'health': '/api/v1/health/status'
                }
            },
            'test_credentials': {
                'admin': {'username': 'admin', 'password': 'admin123'},
                'user': {'username': 'user', 'password': 'user123'}
            },
            'instructions': [
                '1. Visit /api/docs/ for interactive API documentation',
                '2. Login with test credentials to get JWT token',
                '3. Use "Bearer <token>" in Authorization header for protected endpoints',
                '4. All data is stored in database using SQLAlchemy ORM',
                '5. GET requests return real data from database',
                '6. Admin users have access to all management features'
            ]
        })


def _init_db(app: Flask) -> None:
    """
    Initializes DB with SQLAlchemy
    :param app: Flask application object
    """
    app.config.setdefault("SQLALCHEMY_ENGINE_OPTIONS", {})

    db.init_app(app)

    if not database_exists(app.config["SQLALCHEMY_DATABASE_URI"]):
        create_database(app.config["SQLALCHEMY_DATABASE_URI"])

    import my_project.auth.domain
    with app.app_context():
        db.create_all()


def _process_input_config(app_config: Dict[str, Any], additional_config: Dict[str, Any]) -> None:
    """
    Processes input configuration
    :param app_config: Flask configuration
    :param additional_config: additional configuration
    """
    load_dotenv()
    conn = os.getenv(SQLALCHEMY_DATABASE_URI)
    if conn:
        app_config["SQLALCHEMY_DATABASE_URI"] = conn
        return

    user = os.getenv(MYSQL_ROOT_USER, str(additional_config.get("MYSQL_ROOT_USER", "")))
    pwd  = os.getenv(MYSQL_ROOT_PASSWORD, str(additional_config.get("MYSQL_ROOT_PASSWORD", "")))

    template = app_config.get("SQLALCHEMY_DATABASE_URI", "")
    if not template:
        raise ValueError("SQLALCHEMY_DATABASE_URI is missing and no CONNECTION_STRING provided in env.")

    if "{user}" in template or "{password}" in template:
        app_config["SQLALCHEMY_DATABASE_URI"] = template.format(
            user=user,
            password=quote_plus(pwd),
        )
        return

    if "{}" in template:
        app_config["SQLALCHEMY_DATABASE_URI"] = template.format(
            user, quote_plus(pwd)
        )
        return

    app_config["SQLALCHEMY_DATABASE_URI"] = template